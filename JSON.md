# CFEngine Build JSON file format

The CFEngine Build website and tooling relies on JSON files for different purposes;

- The project file (`cfbs.json`) generated by running `cfbs init` when you start a new project
- The index of all available modules which is available on GitHub
- A `cfbs.json` file with necessary metadata for adding a module using URL (not from index)

All these 3 share 1 standard format, commonly called `cfbs.json`.

(There is also [`versions.json`](https://github.com/cfengine/cfbs-index/blob/master/versions.json), but this specification is not about that file).

## Keys

`index`: URL, relative path, or inline dictionary.
Used by `cfbs add` and `cfbs search`, when index key is present in `cfbs.json` in the current working directory.
When adding a module by URL, which has a `cfbs.json` inside of it, the index in that file should be ignored.

## The process of building modules from a project into a policy set

When you build a project with the `cfbs build` command, it loops through all modules in the project (`"build"` key), in order.
Within each module it runs the individual build steps, specified in the `"steps"` key.

As an example, here is a local policy file module with 1 build step:

```json
{
  "name": "./policy.cf",
  "description": "Local policy file added using cfbs command line",
  "tags": ["local"],
  "added_by": "cfbs add",
  "steps": [
    "copy ./policy.cf services/cfbs/policy.cf",
    "policy_files ./policy.cf",
    "bundles my_bundle"
  ]
}
```

In the example above, the `policy.cf` file is copied to `out/masterfiles/services/autorun/policy.cf`.

### Step folders

As a project is built, `cfbs` creates intermediate folders for each module, for example:

```
out/steps/001_masterfiles_5c7dc5b43088e259a94de4e5a9f17c0ce9781a0f/
```

These are copies of the module directories, where it's more "safe" to do things like run scripts or delete files.
`cfbs build` should not edit files in your project / git repository, only the generated / temporary files inside the `out/` directory.

### All available build steps

The build steps below manipulate the temporary files in the steps directories and write results to the output policy set, in `out/masterfiles`.
Unless otherwise noted, all steps are run inside the module's folder (`out/steps/...`) with sources / file paths relative to that folder, and targets / destinations mentioned below are relative to the output policy set (`out/masterfiles`, which in the end will be deployed as `/var/cfengine/masterfiles`)

#### `copy <source> <destination>`
- Copy a single file or a directory recursively.

#### `json <source> <destination>`
- Merge the source json file into the destination json file.

#### `append <source> <destination>`
- Append the source file to the end of destination file.

#### `run <command>`
- Run a shell command / script.
- Usually used to prepare the module directory, delete files, etc. before a copy step.
- Running scripts should be avoided if possible.
- Script is run inside the module directory (the step folder).

#### `delete <paths ...>`
- Delete multiple files or paths recursively.
- Files are deleted from the step folder.
- Typically used before copying files to the output policy set with the `copy` step. 

#### `directory <source> <destination>`
- Copy any .cf policy files recursively and add their paths to `def.json`'s `inputs`.
- Enable `services_autorun_bundles` class in `def.json`.
- Merge any `def.json` recursively into `out/masterfiles/def.json`.
- Copy any other files with their existing directory structure to destination.

#### `bundles <bundles ...>`
- Ensure bundles are evaluated by adding them to the bundle sequence, using `def.json`.
  - Note that this relies on using the default policy set from the CFEngine team, the Masterfiles Policy Framework, commonly added as the first module (`masterfiles`). 
    Specifically, this build step adds the bundles to the variable `default:def.control_common_bundlesequence_end`, which the MPF looks for.
- Only manipulates the bundle sequence, to ensure policy files are copied and parsed, use other build steps, for example `copy` and `policy_files`.

#### `policy_files <paths ...>`
- Add policy (`.cf`) files to `inputs` key in `def.json`, ensuring they are parsed.
  - Note that this relies on using the default policy set from the CFEngine team, the Masterfiles Policy Framework, commonly added as the first module (`masterfiles`).
  - Only edits `def.json`, does not copy files. Should be used after a `copy` or `directory` build step.
  - Does not add any bundles to the bundle sequence, to ensure a bundle is evaluated, use the `bundles` build step or the autorun mechanism.
- All paths are relative to `out/masterfiles`.
- If any of the paths are directories (end with `/`), the folder(s) are recursively searched and all `.cf` files are added.
  - **Note:** Directories should be module-specific, otherwise this build step can find policy files from other modules (when they are mixed in the same directory).

#### `input <source input.json> <target def.json>`
- Converts the input data for a module into the augments format and merges it with the target augments file.
- Source is relative to module directory and target is relative to `out/masterfiles`.
  - In most cases, the build step should be: `input ./input.json def.json`

## Examples

### New project

Starting in an empty folder you can create a new project with the `init` command:

```
cfbs init
```

Which creates a file like this:

```json
{
  "name": "Example",
  "description": "Example description",
  "type": "policy-set",
  "build": []
}
```

### Adding a module

Continuing from the previous project, we can add a module:

```
cfbs add mpf
```

Which results in:

```json
{
  "name": "Example",
  "description": "Example description",
  "type": "policy-set",
  "build": [
    {
      "name": "masterfiles",
      "description": "Official CFEngine Masterfiles Policy Framework (MPF)",
      "tags": ["official", "base", "supported"],
      "repo": "https://github.com/cfengine/masterfiles",
      "by": "https://github.com/cfengine",
      "version": "0.1.1",
      "commit": "5c7dc5b43088e259a94de4e5a9f17c0ce9781a0f",
      "steps": [
        "run ./autogen.sh",
        "delete ./autogen.sh",
        "run ./cfbs/cleanup.sh",
        "delete ./cfbs/cleanup.sh",
        "copy ./ ./"
      ],
      "added_by": "cfbs add"
    }
  ]
}
```

## Alternate index

You can start a project with an alternate index:

```
cfbs init --index blah
```

```json
{
  "name": "Example",
  "description": "Example description",
  "type": "policy-set",
  "index": "blah",
  "build": []
}
```

`blah` can be a URL or a relative file path (inside project).

## Index file

The index file used by `cfbs` also follows the same format:

```json
{
  "name": "Official CFEngine Build Index (default)",
  "description": "File used by tooling and website to find modules",
  "type": "index",
  "index": {
    "masterfiles": {
      "description": "Official CFEngine Masterfiles Policy Framework (MPF)",
      "tags": ["official", "base", "supported"],
      "repo": "https://github.com/cfengine/masterfiles",
      "by": "https://github.com/cfengine",
      "version": "0.1.1",
      "commit": "5c7dc5b43088e259a94de4e5a9f17c0ce9781a0f",
      "steps": [
        "run ./autogen.sh",
        "delete ./autogen.sh",
        "run ./cfbs/cleanup.sh",
        "delete ./cfbs/cleanup.sh",
        "copy ./ ./"
      ]
    }
  }
}
```

(Only showing 1 module here, the real file has many more).

Note that it is reusing the `index` key, but this time with a dictionary (inline index).

## A separate repo which provides modules

If you put your modules in a repo and don't have them in the index (yet), you can use the `provides` key:

```json
{
  "name": "Example module in separate repo",
  "description": "Example description",
  "type": "module",
  "provides": {
    "example-module": {
      "description": "Just an example",
      "tags": ["local"],
      "dependencies": ["autorun"],
      "steps": ["copy ./test.cf services/autorun/test.cf"]
    }
  }
}
```

## Adding a module from repo URL

```
cfbs init && cfbs add https://github.com/cfengine/some-repo
```

```json
{
  "name": "Example",
  "description": "Example description",
  "type": "policy-set",
  "build": [
    {
      "name": "example-module",
      "description": "Just an example",
      "tags": ["local"],
      "url": "https://github.com/cfengine/some-repo",
      "commit": "be3bc015f6a19e945bb7a9fa0ed78c97e2cecf61",
      "dependencies": ["autorun"],
      "steps": ["copy ./test.cf services/autorun/test.cf"],
      "added_by": "cfbs add"
    }
  ]
}
```


## Modules with input
Some modules allow for users to add module input by responding to questions
expressed under the `"input"` attribute in `cfbs.json`. User input can be added
using the `cfbs input <module-name>` command, which stores responses in
`./<module-name>/input.json`. These responses are translated into augments which
will be added to `./out/masterfiles/def.json` during `cfbs build`.

### Create single file example:
The `"input"` attribute takes a list of input definitions as illustrated below.

```json
{
  "name": "Example",
  "type": "policy-set",
  "description": "Example description",
  "build": [
    {
      "name": "create-single-file",
      "description": "Create a single file.",
      "url": "https://github.com/cfengine/example-module.git",
      "commit": "d95774c8c59a2895c677624851ef4ad9d5e0d02d",
      "dependencies": ["autorun"],
      "added_by": "cfbs add",
      "steps": [
        "copy ./create-single-file.cf services/autorun/create-single-file.cf",
        "input ./input.json def.json"
      ],
      "input": [
        {
          "type": "string",
          "variable": "filename",
          "label": "Filename",
          "question": "What file should this module create?"
        }
      ]
    }
  ]
}
```

From the example above, we can see that the `"input"` list contains one input
definition. By running the command `cfbs input create-single-file`, the input
definition will be copied into `./create-single-file/input.json` along with the
user responses.

```
$ cfbs input create-single-file
Adding input for module 'create-single-file':
What file should this module create? /tmp/create-single-file.txt
$ cat ./create-single-file/input.json
[
  {
    "type": "string",
    "variable": "filename",
    "label": "Filename",
    "question": "What file should this module create?",
    "response": "/tmp/create-single-file.txt"
  }
]
```

By running `cfbs build`, augments will be generated from
`./create-single-file/input.json` and added to `./out/masterfiles/def.json`.
Note that this is dependant on the `"input ./input.json def.json"` build step in
`cfbs.json`.

```
$ cfbs build
--snip--
Build complete, ready to deploy 🐿
 -> Directory: out/masterfiles
 -> Tarball:   out/masterfiles.tgz
To install on this machine: sudo cfbs install
To deploy on remote hub(s): cf-remote deploy
$ cat ./out/masterfiles/def.json
{
  "classes": {
    "services_autorun": ["any"]
  },
  "variables": {
    "cfbs:create_single_file.filename": {
      "value": "/tmp/create-single-file.txt",
      "comment": "Added by 'cfbs input'"
    }
  }
}
```

From the example above we can see our beloved `filename`-variable along with a
class generated by the autorun dependency. Studying our variable closer, we can
see that a namespace, bundle, and a comment, were automatically assigned some
default values.  I.e. `cfbs`, the module name canonified, and `Added by 'cfbs
input'` respectivy.  These defaults can easily be overridden using the
`namespace`, `bundle`, and `comment` attributes in the variable definition. E.g.
the following variable definition;

```json
      "input": [
        {
          "type": "string",
          "namespace": "my_namespace",
          "bundle": "my_bundle",
          "variable": "filename",
          "comment": "Example comment.",
          "label": "Filename",
          "question": "What file should this module create?"
        }
      ]
```

would produce the following augment;

```json
{
  "variables": {
    "my_namespace:my_bundle.filename": {
      "value": "/tmp/create-single-file.txt",
      "comment": "Example comment."
    }
  }
}
```

### Create a single file with content example:
A module that creates empty files is not too impressive on its own. Let us
instead try to extend our previous example by having the module also ask for
file contents.

```json
{
  "name": "Example",
  "type": "policy-set",
  "description": "Example description",
  "build": [
    {
      "name": "create-single-file-with-content",
      "description": "Create a single file with content.",
      "url": "https://github.com/cfengine/example-module.git",
      "commit": "d95774c8c59a2895c677624851ef4ad9d5e0d02d",
      "dependencies": ["autorun"],
      "added_by": "cfbs add",
      "steps": [
        "copy ./create-single-file-with-content.cf services/autorun/create-single-file-with-content.cf",
        "input ./input.json def.json"
      ],
      "input": [
        {
          "type": "string",
          "variable": "filename",
          "label": "Filename",
          "question": "What file should this module create?"
        },
        {
          "type": "string",
          "variable": "content",
          "label": "Content",
          "question": "What content should this file have?"
        }
      ]
    }
  ]
}
```

As you can see from the example above, the extension would only require us to
add another variable to the input definition. Let's have a look at the results
from running `cfbs input` with our extension module.

```
$ cfbs input create-single-file-with-content
Adding input for module 'create-single-file-with-content':
What file should this module create? /tmp/create-single-file-with-content.txt
What content should this file have? Hello CFEngine!
$ cfbs build
--snip--
Build complete, ready to deploy 🐿
 -> Directory: out/masterfiles
 -> Tarball:   out/masterfiles.tgz
To install on this machine: sudo cfbs install
To deploy on remote hub(s): cf-remote deploy
$ cat ./out/masterfiles/def.json
{
  "classes": {
    "services_autorun": ["any"]
  },
  "variables": {
    "cfbs:create_single_file_with_content.filename": {
      "value": "/tmp/create-single-file-with.content.txt",
      "comment": "Added by 'cfbs input'"
    }
    "cfbs:create_single_file_with_content.content": {
      "value": "Hello CFEngine!",
      "comment": "Added by 'cfbs input'"
    }
  }
}
```

### Create multiple files example:
Sometimes we would like a module to support taking an arbritary number of
inputs. This can be done using a variable definition of type list. Let's extend
our first example from creating a single to multiple files.

```json
{
  "name": "Example",
  "type": "policy-set",
  "description": "Example description",
  "build": [
    {
      "name": "create-multiple-files",
      "description": "Create multiple files.",
      "url": "https://github.com/cfengine/example-module.git",
      "commit": "d95774c8c59a2895c677624851ef4ad9d5e0d02d",
      "dependencies": ["autorun"],
      "added_by": "cfbs add",
      "steps": [
        "copy ./create-multiple-files.cf services/autorun/create-multiple-files.cf",
        "input ./input.json def.json"
      ],
      "input": [
        {
          "type": "list",
          "variable": "files",
          "label": "Files",
          "subtype": {
            "type": "string",
            "label": "Filename",
            "question": "What file should this module create?"
          },
          "while": "Do you want to create another file?"
        }
      ]
    }
  ]
}
```

Running `cfbs input` with our module supporting multiple files, we can expect
the following interaction:

```
$ cfbs input create-multiple-files
Adding input for module 'create-multiple-files':
What file should this module create? /tmp/create-multiple-files-1.txt
Do you want to create another file? yes
What file should this module create? /tmp/create-multiple-files-2.txt
Do you want to create another file? no
```

The *_./create-multiple-files/input.json_* file would look similar to the
following JSON:

```json
[
  {
    "type": "list",
    "variable": "files",
    "label": "Files",
    "subtype": {
      "type": "string",
      "label": "Filename",
      "question": "What file should this module create?",
    },
    "while": "Do you want to create another file?",
    "response": [
      "/tmp/create-multiple-files-1.txt",
      "/tmp/create-multiple-files-2.txt"
    ]
  }
]
```

And if we build our project we can expect something similar to the following
output:

```
$ cfbs build
--snip--
Build complete, ready to deploy 🐿
 -> Directory: out/masterfiles
 -> Tarball:   out/masterfiles.tgz
To install on this machine: sudo cfbs install
To deploy on remote hub(s): cf-remote deploy
$ cat ./out/masterfiles/def.json
{
  "classes": {
    "services_autorun": ["any"]
  },
  "variables": {
    "cfbs:create_multiple_files.files": {
      "value": [
        "/tmp/create-multiple-files-1.txt",
        "/tmp/create-multiple-files-2.txt"
      ],
      "comment": "Added by 'cfbs input'"
    }
  }
}
```

### Create multiple files with content example:
As a final example, let's see how we can build a module that takes an arbritary
number of filename and content pairs as input.

```json
{
  "name": "Example",
  "type": "policy-set",
  "description": "Example description",
  "build": [
    {
      "name": "create-multiple-files-with-content",
      "description": "Create multiple files with content.",
      "url": "https://github.com/cfengine/example-module.git",
      "commit": "d95774c8c59a2895c677624851eb4ad9d5e0d02d",
      "dependencies": ["autorun"],
      "added_by": "cfbs add",
      "steps": [
        "copy ./create-multiple-files-with-content.cf services/autorun/create-multiple-files-with-content.cf",
        "input ./input.json def.json"
      ],
      "input": [
        {
          "type": "list",
          "variable": "files",
          "label": "Files",
          "subtype": [
            {
              "key": "name",
              "type": "string",
              "label": "Name",
              "question": "What file should this module create?"
            },
            {
              "key": "content",
              "type": "string",
              "label": "Content",
              "question": "What content should this file have?"
            }
          ],
          "while": "Do you want to create another file?"
        }
      ]
    }
  ]
}
```

Just like before we add input, build and look at the result:

```
$ cfbs input create-multiple-files-with-content
Adding input for module 'create-multiple-files-with-content':
What file should this module create? /tmp/create-multiple-files-with-content-1.txt
What content should this file have? Hello CFEngine!
Do you want to create another file? yes
What file should this module create? /tmp/create-multiple-files-with-content-2.txt
What content should this file have? Bye CFEngine!
Do you want to create another file? no
$ cfbs build
--snip--
Build complete, ready to deploy 🐿
 -> Directory: out/masterfiles
 -> Tarball:   out/masterfiles.tgz
To install on this machine: sudo cfbs install
To deploy on remote hub(s): cf-remote deploy
$ cat ./out/masterfiles/def.json
{
  "classes": {
    "services_autorun": ["any"]
  },
  "variables": {
    "cfbs:create_multiple_files_with_content.file": {
      "value": [
        {
          "name": "/tmp/create-multiple-files-with.content-1.txt",
          "content": "Hello CFEngine!"
        },
        {
          "name": "/tmp/create-multiple-files-with.content-2.txt",
          "content": "Bye CFEngine!"
        }
      ]
      "comment": "Added by 'cfbs input'"
    }
  }
}
```
